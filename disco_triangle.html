<!DOCTYPE html>
<html lang="en">
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<script src="webgl_book_examples/lib/cuon-matrix.js"></script>
<script>
// Animate a multicolored triangle using a single interleaved vertex buffer.
// try setting colors via fragcoord.

// GLSL vertex shader
var VSHADER_SOURCE = 
  'attribute vec4 a_Position; attribute vec4 a_Color;' +
  'varying vec4 v_Color;' +
  'uniform mat4 u_PositionShift;' +
  'void main(){gl_Position = a_Position * u_PositionShift; gl_PointSize = 1.0; v_Color = a_Color;}';

// GLSL fragment shader
var FSHADER_SOURCE = 
  'precision mediump float; varying vec4 v_Color;' +
  'uniform mat4 u_ColorShift;' +
  // 'void main(){gl_FragColor = v_Color * u_ColorShift * u_ColorShift;}';
  'void main(){' +
    'float dd = 15.0;' +
    'float rd = sqrt(pow(0.5 - mod(gl_FragCoord.x,dd)/dd, 2.0) + pow(0.5 - mod(gl_FragCoord.y,dd)/dd, 2.0));' +
    'vec4 cs = v_Color * u_ColorShift;' +
    'gl_FragColor = vec4(max(cs.x - rd, 0.0), max(cs.y - rd, 0.0), max(cs.z- rd, 0.0), 1.0);}';

var canvas = document.getElementById('canvas');
var gl = canvas.getContext('webgl');

// Create shader objects
var vshader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vshader, VSHADER_SOURCE);
gl.compileShader(vshader);

var fshader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fshader, FSHADER_SOURCE);
gl.compileShader(fshader);

// Create and configure a program object
var program = gl.createProgram();
gl.attachShader(program, vshader);
gl.attachShader(program, fshader);
gl.linkProgram(program);
  
// clear the drawing area
gl.clearColor(0.0,0.0,0.1,1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

// handles for uniform variables (for animating rotations)
var u_ColorShift = gl.getUniformLocation(program, 'u_ColorShift');
var u_PositionShift = gl.getUniformLocation(program, 'u_PositionShift');

// create, bind & populate buffer (CPU side)
var vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
var vertexData = new Float32Array([
	0.0, 0.5, 1.0, 0.0, 0.0,
   -0.5,-0.5, 0.0, 1.0, 0.0,
    0.5,-0.5, 0.0, 0.0, 1.0
	]);
var FSIZE = vertexData.BYTES_PER_ELEMENT;
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

// run the program
gl.useProgram(program);

// animation setup
var degB = 0;
var ANGLE_PER_SECOND = 120;
var lastStepTime = Date.now();

// TODO exercise: Encapsulate the animation logic for the angle into an appropriate JS abstraction

// function AnimAngle(startAngle, anglePerSecond){
//   this.degB = startAngle;

// };

function tick(){
  gl.clear(gl.COLOR_BUFFER_BIT);

  // calculate amount of angle to rotate by, given ANGLE_PER_SECOND
  var radB = degB * Math.PI / 180.0;
  var now = Date.now();
  degB += ANGLE_PER_SECOND * (now - lastStepTime) / 1000.0 ;
  lastStepTime = now;

  // create transform matrix based on degB and radB as computed above.
  var xformMatrix = new Matrix4();
  
  // set matrix for color rotation
  xformMatrix.setRotate(degB,1.0,1.0,1.0);
  gl.uniformMatrix4fv(u_ColorShift, false, xformMatrix.elements);

// set matrix for position rotation
  xformMatrix.setRotate(degB/5,Math.cos(radB/11),Math.sin(radB/7),1.0);
  gl.uniformMatrix4fv(u_PositionShift, false, xformMatrix.elements);

  // describe position data layout in buffer (GPU side)
  var a_Position = gl.getAttribLocation(program, 'a_Position');
  gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 5, 0);
  gl.enableVertexAttribArray(a_Position);

  // color data layout next (GPU side)
  var a_Color = gl.getAttribLocation(program, 'a_Color');
  gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 5, FSIZE * 2);
  gl.enableVertexAttribArray(a_Color);

  gl.drawArrays(gl.TRIANGLES, 0, 3);

  requestAnimationFrame(tick);
}
tick();

</script>
</body>
</html>